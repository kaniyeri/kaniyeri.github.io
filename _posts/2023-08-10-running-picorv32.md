---
layout: post
title: Running your own programs on the PicoRV32
---
---

[PicoRV32](https://github.com/YosysHQ/picorv32) is an open source core that implements the RISC-V RV32IMC Instruction Set. Here's how to use the core to run your own programs.


This is the structure of the repository:
```
x@y:~/Desktop/picorv32-1.0$ tree -L 1
.
├── dhrystone
├── dotfiles
├── firmware
├── iverilog
├── Makefile
├── obj_dir
├── picoramsoc-master
├── picorv32.core
├── picorv32.v
├── picosoc
├── README.md
├── scripts
├── self
├── shell.nix
├── showtrace.py
├── testbench.cc
├── testbench_ez.v
├── testbench.v
├── testbench.vvp
├── testbench_wb.v
├── tests
└── yosys
```

Run `make test` just to make sure you have all the prerequisites installed.

<p class="message"> The version of iverilog on the debian apt repository is old (10.3). Build it from source by following the instructions on the iverilog repository. </p>

# Makefile and Compilation

The makefile provides the method in which the files are compiled and arranged. Highlighting the important sections:

```make
FIRMWARE_OBJS = firmware/start.o firmware/irq.o firmware/print.o firmware/sieve.o firmware/multest.o firmware/stats.o

...

test: testbench.vvp firmware/firmware.hex
	vvp -N $<

...

firmware/firmware.hex: firmware/firmware.bin firmware/makehex.py
	python3 firmware/makehex.py $< 16384 > $@

firmware/firmware.bin: firmware/firmware.elf
	$(TOOLCHAIN_PREFIX)objcopy -O binary $< $@
	chmod -x $@

firmware/firmware.elf: $(FIRMWARE_OBJS) $(TEST_OBJS) firmware/sections.lds 
	$(TOOLCHAIN_PREFIX)gcc -Os -ffreestanding -nostdlib -o $@ \
		-Wl,-Bstatic,-T,firmware/sections.lds,-Map,firmware/firmware.map,--strip-debug \
		$(FIRMWARE_OBJS) $(TEST_OBJS) -lgcc
	chmod -x $@

firmware/start.o: firmware/start.S
	$(TOOLCHAIN_PREFIX)gcc -c -march=rv32im$(subst C,c,$(COMPRESSED_ISA)) -o $@ $<

firmware/%.o: firmware/%.c
	$(TOOLCHAIN_PREFIX)gcc -c -march=rv32i$(subst C,c,$(COMPRESSED_ISA)) -Os --std=c99 $(GCC_WARNS) -ffreestanding -nostdlib -o $@ $<
    
```

The object files are built first from the source files using the RV32I toolchain. The files are linked with a custom linker file sections.lds in the firmware folder. 

```lds
SECTIONS {
	.memory : {
		. = 0x000000;
		start*(.text);
		*(.text);
		*(*);
		end = .;
	} > mem
}
```

Linker files tell the compiler how to place the various objects in the executable. Here `. = 0x0` says we start at memory location 0x0 (not necessary, since it is predefined to be 0x0 anyway). `start*` matches any files with names starting with `start`, thereby including `start.o` (`.text` section) as the first file. Next, it includes the `.text` section of any file, and then includes any other file left.


From here, `firmware.bin` is generated by using the `objcopy` tool. It generates a memory dump that does not have any section headers or other such information.

`makehex.py` is a utility script included with the PicoRV32 repository. It arranges the generated `.bin` file in a way that can be copied directly into a memory used in the core. The generated output file `firmware.hex` can be directly read in a compatible memory by using the `$readmemh` command. More on that later.

#

